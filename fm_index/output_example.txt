Esempio di esecuzione del programma fm_index_demo.py
Input: banana

──────────────────────────────────────────────────────────────────────────────
FM-index didattico (BWT / C / Occ / LF / Backward Search)
──────────────────────────────────────────────────────────────────────────────
Inserisci il testo T (NON inserire '$'): banana

──────────────────────────────────────────────────────────────────────────────
Input
──────────────────────────────────────────────────────────────────────────────
T  = 'banana'
T$ = 'banana$'
n  = 7
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
Matrice delle rotazioni (concettuale)
──────────────────────────────────────────────────────────────────────────────
 0: $banana
 1: a$banan
 2: ana$ban
 3: anana$b
 4: banana$
 5: na$bana
 6: nana$ba
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
1) Suffix Array (SA)
──────────────────────────────────────────────────────────────────────────────
SA = [6, 5, 3, 1, 0, 4, 2]

Indice  SA[i]   suffisso
-----  -----   ----------------
    0      6   $
    1      5   a$
    2      3   ana$
    3      1   anana$
    4      0   banana$
    5      4   na$
    6      2   nana$
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
2) Burrows–Wheeler Transform
──────────────────────────────────────────────────────────────────────────────
L (BWT) = annb$aa
F       = $aaabnn

Interpretazione: L[i] è il carattere che precede il suffisso che inizia in SA[i].
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
3) Array C
──────────────────────────────────────────────────────────────────────────────
C[c] = # simboli in L strettamente minori di c (alfabeto ordinato)
  C['$'] = 0
  C['a'] = 1
  C['b'] = 4
  C['n'] = 5
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
4) Operazione Occ (rank su prefissi semiaperti)
──────────────────────────────────────────────────────────────────────────────
Occ(c,i) = # occorrenze di c nel prefisso L[0..i)
Indice i:      0  1  2  3  4  5  6  7
L (BWT):          a  n  n  b  $  a  a
Occ('$',i):  0  0  0  0  0  1  1  1
Occ('a',i):  0  1  1  1  1  1  2  3
Occ('b',i):  0  0  0  0  1  1  1  1
Occ('n',i):  0  0  1  2  2  2  2  2
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
5) LF-mapping
──────────────────────────────────────────────────────────────────────────────
Definizione: LF(i) = C[L[i]] + Occ(L[i], i)

i   SA[i]   L[i]   LF(i)   suffisso
--  -----  -----  -----   ----------------
 0      6      a      1   $
 1      5      n      5   a$
 2      3      n      6   ana$
 3      1      b      4   anana$
 4      0      $      0   banana$
 5      4      a      2   na$
 6      2      a      3   nana$
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
6) Invertibilità (ricostruzione da L via LF)
──────────────────────────────────────────────────────────────────────────────
Testo ricostruito = 'banana$'

Trace (row, L[row], LF(row)) a partire dalla riga con '$':
  step  0: row= 4  L[row]='$'  -> LF(row)= 0
  step  1: row= 0  L[row]='a'  -> LF(row)= 1
  step  2: row= 1  L[row]='n'  -> LF(row)= 5
  step  3: row= 5  L[row]='a'  -> LF(row)= 2
  step  4: row= 2  L[row]='n'  -> LF(row)= 6
  step  5: row= 6  L[row]='a'  -> LF(row)= 3
  step  6: row= 3  L[row]='b'  -> LF(row)= 4
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
7) Backward Search (FM-index)
──────────────────────────────────────────────────────────────────────────────
Inserisci un pattern P (invio per terminare): ana
Pattern P = 'ana' (ricerca da destra verso sinistra)
Update: sp' = C[c] + Occ(c, sp)   |   ep' = C[c] + Occ(c, ep)

passo  c   [sp,ep) -> [sp',ep')        calcoli
-----  -   ---------------------       ------------------------------
    1  'a'   [ 0, 7) -> [ 1, 4)       sp'=1+Occ('a',0)=1+0=1;  ep'=1+Occ('a',7)=1+3=4
    2  'n'   [ 1, 4) -> [ 5, 7)       sp'=5+Occ('n',1)=5+0=5;  ep'=5+Occ('n',4)=5+2=7
    3  'a'   [ 5, 7) -> [ 2, 4)       sp'=1+Occ('a',5)=1+1=2;  ep'=1+Occ('a',7)=1+3=4

Risultato: intervallo finale [2,4) ⇒ occorrenze = 2
Posizioni nel testo (via SA[sp..ep-1]): [3, 1]
Verifica in T:
  T[3:6] = 'ana'
  T[1:4] = 'ana'
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
7) Backward Search (FM-index)
──────────────────────────────────────────────────────────────────────────────
Inserisci un pattern P (invio per terminare): na
Pattern P = 'na' (ricerca da destra verso sinistra)
Update: sp' = C[c] + Occ(c, sp)   |   ep' = C[c] + Occ(c, ep)

passo  c   [sp,ep) -> [sp',ep')        calcoli
-----  -   ---------------------       ------------------------------
    1  'a'   [ 0, 7) -> [ 1, 4)       sp'=1+Occ('a',0)=1+0=1;  ep'=1+Occ('a',7)=1+3=4
    2  'n'   [ 1, 4) -> [ 5, 7)       sp'=5+Occ('n',1)=5+0=5;  ep'=5+Occ('n',4)=5+2=7

Risultato: intervallo finale [5,7) ⇒ occorrenze = 2
Posizioni nel testo (via SA[sp..ep-1]): [4, 2]
Verifica in T:
  T[4:6] = 'na'
  T[2:4] = 'na'
Premi INVIO per continuare

──────────────────────────────────────────────────────────────────────────────
7) Backward Search (FM-index)
──────────────────────────────────────────────────────────────────────────────
Inserisci un pattern P (invio per terminare):